(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[41],{

/***/ "R6I8":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _HOC_load_HOC_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ebhq");
/* harmony import */ var zerod_standard_md__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("lgEO");
/* harmony import */ var zerod_standard_md__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(zerod_standard_md__WEBPACK_IMPORTED_MODULE_1__);

var AmdDocHOC = _HOC_load_HOC_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].AmdDocHOC;

/* harmony default export */ __webpack_exports__["default"] = (AmdDocHOC(zerod_standard_md__WEBPACK_IMPORTED_MODULE_1___default.a));

/***/ }),

/***/ "SX+g":
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__("sG4F"))(498);

/***/ }),

/***/ "jjl2":
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./AmdDocHOC/index.jsx": "pnNO",
	"./AshowDemoHOC/index.jsx": "+fre"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "jjl2";

/***/ }),

/***/ "lgEO":
/***/ (function(module, exports) {

module.exports = "<div class=\"z-doc-titles\"></div>\n\n<h1 id=\"-\">代码书写约定规范</h1>\n<p>1、scss : className 的单词之间以“-”连接,如<code>z-panel-body</code>; 相同的样式值多次使用到请使用变量（scss 变量写法如：<code>$--border-color:#f0fef2</code>）;</p>\n<p>2、js : 变量名和普通函数名如果是多个单词,请使用骆驼峰形式如<code>myName</code>，构造函数名和 class 类名,请以首字母大写、多个单词以骆驼峰形式，如<code>MyComponent</code>;</p>\n<p>3、js : 声明函数参数超过 3 个时，请使用对象参数形式，如 <code>showMyDreams(show,isBox,byElement)</code>,<code>showMyDreams({show,isBox,byElement,allData})</code>;</p>\n<p>4、react : 禁用组件生命周期函数：<code>componentWillMount</code>、<code>componentWillReceiveProps</code>、<code>componentWillUpdate</code>,因为这些可能在以后 react 中被废弃的函数;</p>\n<p>5、react : ref 属性禁用字符串方式, 如禁用<code>&lt;div ref=&quot;myBox&quot;&gt;&lt;/div&gt;</code>，推荐用法<code>&lt;div ref={(el)=&gt;{this.myBoxEl=el;}}&gt;&lt;/div&gt;</code> 或者使用 <code>React.createRef()</code>;</p>\n<p>6、react : 组件内跟<code>setState</code>无关的属性，请不要写进 <code>state</code>中。</p>\n<p>7、react : v16.7.0之前的react组件写法：(建议继承<code>React.PureComponent</code>)</p>\n<pre><code class=\"language-jsx\">import React from &quot;react&quot;;\nimport PropTypes from &quot;prop-types&quot;;\n\nclass MyComponent extends React.PureComponent {\n    // 定义props的类型(如果有props规定必须要写)\n    static propTypes = {\n        className: PropTypes.string,\n        children: PropTypes.any,\n    };\n    // props的默认值（如果需要）\n    static defaultProps = {\n        className: &quot;z-body&quot;,\n    };\n    // 定义初始state\n    state = {\n        listData: [],\n    };\n    // 安装组件（插入树中）后\n    componentDidMount(){\n\n    },\n    // props更新或state更新后\n    componentDidUpdate(prevProps,prevState){\n\n    },\n    // 卸载和销毁组件之前\n    componentWillUnmount(){\n\n    }\n    render() {\n        const { className, children } = this.props;\n        return (\n            &lt;div className={className}&gt;\n                {this.state.listData.map((item) =&gt; {\n                    return &lt;p&gt;{item.name}&lt;/p&gt;;\n                })}\n                {children}\n            &lt;/div&gt;\n        );\n    }\n}</code></pre>\n<p class=\"z-margin-bottom-30 \"></p>\n\n<h1 id=\"zerod-admin-webpack-\">zerod-admin-webpack 开发约定规范</h1>\n<p>以下看到的<code>@</code>符号，是开发目录 <code>src</code> 的别名（绝对路径）</p>\n<div class=\"z-doc-titles\"></div>\n\n<h2 id=\"-api\">后台接口 @/Api</h2>\n<p>0、后台接口请求响应体应该这样的 ： { code:状态码,data:数据 ,msg:&quot;提示&quot; }</p>\n<p>1、<code>@/App.api.js</code> 会自动加载 <code>@/Api/</code>下的<code>.api.js</code></p>\n<p>2、对应后台 <code>swagger</code> 接口文档，如login分类的接口，就创建一个<code>login.api.js</code>，在这个js中统一写login相关的接口函数</p>\n<p>3、规定写法：</p>\n<pre><code class=\"language-jsx\">// 例如login.api.js\nimport httpAjax from &quot;@/zTool/httpAjax&quot;;\nexport default {\n    name: &quot;login&quot;, //空间命名，用于支持多个.api.js中的apis出现相同的函数命名\n    apis: {\n        //获取列表接口\n        getList(query) {\n            return httpAjax(&quot;post&quot;, &quot;接口路径&quot;, query);\n        },\n        //获取验证码\n        getCode(query) {\n            return httpAjax(&quot;get&quot;, &quot;接口路径&quot;, query);\n        },\n    },\n};</code></pre>\n<p>4、例如在<code>Home/index.jsx</code>中使用接口</p>\n<pre><code class=\"language-jsx\">// 导入@/App.api.js即可\nimport api from &quot;@/App.api.js&quot;;\n\napi.login.getList(查询参数).then(re=&gt;{\n\n}).catch(re=&gt;{\n\n}).finally(()=&gt;{\n\n});</code></pre>\n<div class=\"z-doc-titles\"></div>\n\n<h2 id=\"-\">静态资源</h2>\n<p>1、衡量小文件可进行打包处理的，统一放 <code>@/assets</code> 目录，如小图片在 <code>@/assets/images</code></p>\n<p>2、较大文件，不宜打包处理的，统一放 <code>static</code>目录，但不能 <code>import png from &#39;../static/images/my.png&#39;</code> 的方式引入， 以<code>&lt;img src=&quot;../../static/images/my.png&quot;&gt;</code>等方式使用</p>\n<div class=\"z-doc-titles\"></div>\n\n<h2 id=\"-components\">通用组件 @/components</h2>\n<p>1、组件命名：以大写<code>A</code>开头，驼峰命名法</p>\n<p>2、一个大组件就是一个文件夹，文件夹命名与组件命名相同，里面有对应的 <code>index.jsx（必需文件）</code>和 <code>style.scss</code>,<br>如 <code>AtabBar</code> 组件。</p>\n<pre><code class=\"language-jsx\">//例子：AtabBar 的 index.jsx\n//使用模块化的css\nimport cssClass from &quot;./style.scss&quot;;\n\nimport React from &quot;react&quot;;import ZpureComponent from &quot;zerod/components/ZpureComponent&quot;;\nclass AtabBar extends ZpureComponent {\n    render(){\n        return &lt;div&gt;&lt;/div&gt;\n    }\n}\nexport default {\n    name: &quot;AtabBar&quot;, //组件命名(必需)\n    component: AtabBar, //必需\n};</code></pre>\n<p>3、<code>@/components</code> 下的所有 <code>index.jsx</code>会在 <code>@/components/load-components.js</code>自动加载，使用的时候如</p>\n<pre><code class=\"language-jsx\">//例如，在路由组件中使用通用组件只需\nimport components from &quot;@/components/load-components&quot;;\n//然后必须这样：需要什么组件，将组件命名const出来\nconst { AtabBar, ApageTitle } = components;</code></pre>\n<div class=\"z-doc-titles\"></div>\n\n<h2 id=\"hoc-hoc\">HOC 组件 @/HOC</h2>\n<p>1、组件命名：以大写<code>A</code>开头<code>HOC</code>结尾</p>\n<p>2、一个大组件就是一个文件夹，文件夹命名与组件命名相同，里面有对应的 <code>index.jsx（必需文件）</code>和 <code>style.scss</code><br>如 <code>AshowDemoHOC</code> 组件。</p>\n<pre><code class=\"language-jsx\">//例子：AshowDemoHOC 的 index.jsx\n//使用模块化的css\nimport cssClass from &quot;./style.scss&quot;;\n\nimport React from &quot;react&quot;;import ZpureComponent from &quot;zerod/components/ZpureComponent&quot;;\nfunction AshowDemoHOC(Comp) {\n    return class Common extends ZpureComponent {\n        render() {\n            return &lt;Comp /&gt;;\n        }\n    };\n}\n\nexport default {\n    name: &quot;AshowDemoHOC&quot;, //组件命名(必需)\n    component: AshowDemoHOC, //必需\n};</code></pre>\n<p>3、<code>@/HOC</code> 下的所有 <code>index.jsx</code>会在 <code>@/HOC/load-HOC.js</code>自动加载，使用的时候如</p>\n<pre><code class=\"language-jsx\">//例如，在路由组件中使用HOC组件只需\nimport HOC from &quot;@/components/load-HOC&quot;;\n//然后必须这样：需要什么组件，将组件命名解构出来\nconst { AshowDemoHOC } = HOC;\nconst NewComponent = AshowDemoHOC(config);</code></pre>\n<div class=\"z-doc-titles\"></div>\n\n<h2 id=\"-views\">路由组件 @/views</h2>\n<p>0、一个路由组件就是一个文件夹，文件夹命名：以大写字母开头，驼峰命名法</p>\n<p>1、<code>@/views</code>下的目录结构按照路由层级结构划分</p>\n<p>2、每个路由组件有对应的 <code>index.jsx、style.scss</code> 和<code>A.route.js(路由配置)</code></p>\n<p>3、路由组件一般使用异步加载，使用 <code>@/lazyLoad/</code>懒加载：</p>\n<pre><code class=\"language-jsx\">//例如：Home页面有 index.jsx、style.scss和Home.route.js\n// A.route.js写法：\nimport lazyLoad from &quot;@/lazyLoad/lazyLoad&quot;;\nconst Home = lazyLoad(()=&gt;import(&quot;./&quot;));\nexport default [\n    {\n        path: &quot;/Home&quot;,\n        component: Home,\n    },\n];</code></pre>\n<div class=\"z-doc-titles\"></div>\n\n<h2 id=\"-store\">状态管理仓库 @/store</h2>\n<p>状态管理的工具使用的是<code>redux</code> + <code>react-redux</code></p>\n<p><code>@/store</code>主要分为三个部分：<code>reducers</code>、<code>actions</code>、<code>mapStateToProps</code></p>\n<p><code>@/store/index.js</code>中创建了 store，绝大多数不需要修改此文件</p>\n<p>如果要设置 store 中某些状态的初始值，请在<code>@/store/initialState.js</code>配置</p>\n<h3 id=\"reducers\">reducers</h3>\n<p>绝大多数不需要修改<code>@/store/reducers/index.js</code>，它自动加载了<code>@/store/reducers</code>下所有以<code>.mutation.js</code>后缀的文件</p>\n<p><code>.mutation.js</code>内书写的格式如下：</p>\n<pre><code class=\"language-js\">// 变异状态 例子：\nexport default {\n    //命名空间，用于区分 多个.mutation.js里mutations中存在相同函数名\n    name: &quot;evaluate&quot;,\n    //状态变异的函数结构:\n    mutations: {\n        // 如果 actions/index.js中 type 为&quot;evaluate.changeInput1&quot;的action函数被触发，就会触发这里的changeInput1函数去变异相应的状态\n        changeInput1(state, action) {\n            return {\n                ...state,\n                currentValue: action.payload.value,\n            };\n        },\n        // 同理\n        changeInput2(state, action) {\n            return {\n                ...state,\n                maxValue: action.payload.value,\n            };\n        },\n    },\n};</code></pre>\n<h3 id=\"actions\">actions</h3>\n<p>actions 的作用是，其他地方或者其他组件内部想要改变 store 仓库里的什么状态</p>\n<p><code>@/store/actions/index.js</code>内书写的格式如下：</p>\n<pre><code class=\"language-js\">// action函数之一\nexport const numberChange1 = (value) =&gt; ({\n    type: &quot;evaluate.changeInput1&quot;, //要触发的是 命名空间为evaluate的 `.mutation.js`中的 `changeInput1`函数\n    payload: {\n        value,\n    },\n});\n// action函数之一\nexport const numberChange2 = (value) =&gt; ({\n    type: &quot;evaluate.changeInput2&quot;, // 同理\n    payload: {\n        value,\n    },\n});</code></pre>\n<h3 id=\"mapstatetoprops\">mapStateToProps</h3>\n<p>mapStateToProps 的作用是，其他地方或者其他组件内部想要取 store 仓库中的什么状态</p>\n<p><code>@/store/mapStateToProps/index.js</code>内书写的格式如下：</p>\n<pre><code class=\"language-js\">//mapStateToProps函数之一\nexport const getInputValueState1 = function(state) {\n    // 这里取得 store仓库中的currentValue状态 给某个组件的props.value\n    return {\n        value: state.currentValue,\n    };\n};\n//mapStateToProps函数之一\nexport const getInputValueState2 = function(state) {\n    // 这里取得 store仓库中的maxValue状态 给某个组件的props.value\n    return {\n        value: state.maxValue,\n    };\n};</code></pre>\n<h3 id=\"react-redux-connect\">react-redux 的 connect</h3>\n<p>当已经写好了<code>.mutation.js</code>、<code>actions</code>、<code>mapStateToProps</code>，这时需要<code>connect</code>将<code>mapStateToProps</code>和<code>actons</code>与<code>组件</code>进行连接</p>\n<p>假如有 <code>Input</code> 这样的组件,它有 value 和 onChange 两个 props，它与 <code>mapStateToProps</code>和<code>actions</code>的连接如下：</p>\n<pre><code class=\"language-jsx\">import React from &quot;react&quot;;import ZpureComponent from &quot;zerod/components/ZpureComponent&quot;;\nimport { Input } from &quot;antd&quot;;\nimport { connect } from &quot;react-redux&quot;;\nimport { numberChange1 } from &quot;@/store/actions&quot;;\nimport { getInputValueState1 } from &quot;@/store/mapStateToProps&quot;;\n\nconst NewInput = connect(\n    getInputValueState1,\n    {\n        onChange: numberChange1,\n    },\n)(Input);</code></pre>\n<div class=\"z-doc-titles\"></div>\n\n<h2 id=\"react-\">react 上下文 使用</h2>\n<p>1、<code>@/App.context.js</code> 会自动加载 <code>@/context/</code>下的以大写字母开头且以<code>Context</code>结尾的<code>.js</code></p>\n<p>2、例：<code>AppRootContext.js</code></p>\n<pre><code class=\"language-jsx\">import React from &quot;react&quot;;import ZpureComponent from &quot;zerod/components/ZpureComponent&quot;;\nconst defaultValue = {};\nconst context = React.createContext(defaultValue); //创建上下文\nconst { Provider, Consumer } = context;\n//提供启用上下文的方法\nconst setConsumer = (ChildComponent) =&gt; {\n    return class ContextConsumer extends ZpureComponent {\n        render() {\n            return &lt;Consumer&gt;{(value) =&gt; &lt;ChildComponent {...this.props} {...value} /&gt;}&lt;/Consumer&gt;;\n        }\n    };\n};\nexport default {\n    name: &quot;AppRootContext&quot;, //上下文名称（必需）,首字母要大写,以Context结尾\n    loadingText: &quot;加载中...&quot;, //一些固定值\n    Provider,\n    Consumer,\n    setConsumer,\n};</code></pre>\n<p>3、使用上下文 例子：</p>\n<p>上文</p>\n<pre><code class=\"language-jsx\">//引入上下文\nimport contexts from &quot;@/App.context.js&quot;;\n//将上下文的名称 const 出来\nconst { AppRootContext } = contexts;\n\n//在 App.jsx中通过 AppRootContext.Provider 组件更改 上文value\n&lt;AppRootContext.Provider\n    value={{\n        updateLoading: this.methods.updateLoading,\n        timeoutHideLoading: this.methods.timeoutHideLoading,\n        updateDialog: this.methods.updateDialog,\n        updatePicker: this.methods.updatePicker,\n        setPageStorage: this.methods.setPageStorage,\n        getPageStorage: this.methods.getPageStorage,\n        clearPageStorage: this.methods.clearPageStorage,\n    }}\n&gt;\n    {/*这里包含下文的组件*/}\n&lt;/AppRootContext.Provider&gt;;</code></pre>\n<p>下文</p>\n<pre><code class=\"language-jsx\">//引入上下文\nimport contexts from &quot;@/App.context.js&quot;;\n//将上下文的名称 const 出来\nconst { AppRootContext } = contexts;\n\n//在 Report/index.jsx中通过 AppRootContext.setConsumer(Report) 获取上文的value\n//这时在 Report组件中就可以 通过props使用这些东西\n\nthis.props.updateLoading();\nthis.props.timeoutHideLoading();\nthis.props.updateDialog();</code></pre>\n";

/***/ })

}]);
//# sourceMappingURL=41.b8ae97b73b58909afabe.js.map