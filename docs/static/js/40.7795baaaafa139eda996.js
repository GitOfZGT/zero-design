/*{
    "version": "1.0.0",
    "platform": "darwin",
    "buildTime": "2021-10-18 18:05:50"
}*/
(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{"/Ykg":function(n,e,o){"use strict";var a=o("K6wJ");Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.Zviewer=void 0;var c=a(o("q8s6")),t=a(o("MAG/")),p=a(o("6iOh")),r=a(o("1rR9")),d=a(o("IPZl")),l=a(o("v6s4")),s=a(o("kRUu")),i=a(o("XcRB")),u=a(o("ryJs"));o("hfS7"),o("axcb");var g=a(o("vApo")),f=o("V0j1"),m=o("7JPH"),h=a(o("nyVi"));function v(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var o,a=(0,d.default)(n);if(e){var c=(0,d.default)(this).constructor;o=Reflect.construct(a,arguments,c)}else o=a.apply(this,arguments);return(0,r.default)(this,o)}}var b=function(n){(0,p.default)(o,n);var e=v(o);function o(){var n;(0,c.default)(this,o);for(var a=arguments.length,t=new Array(a),p=0;p<a;p++)t[p]=arguments[p];return(n=e.call.apply(e,[this].concat(t))).initViewer=(0,h.default)((function(){n.viewer?n.viewer.update():n.props.urls.length&&(n.viewer=new u.default(n.imgsEl,{transition:!1,url:function(n){return n.dataset.url},hide:n.props.onViewerHide,ready:function(){var e=n.viewer.viewer?n.viewer.viewer:null;if(e&&null===e.querySelector(".z-next")){var o=document.createElement("div"),a=document.createElement("div");o.className="z-next",a.className="z-prev",o.innerHTML='<i  class="zero-icon zerod-next"/>',a.innerHTML='<i  class="zero-icon zerod-prev"/>',e.appendChild(o),e.appendChild(a),o.addEventListener("click",(function(){n.viewer.next(!0)}),!1),a.addEventListener("click",(function(){n.viewer.prev(!0)}),!1)}}})),n.props.viewerUpdated&&n.props.viewerUpdated()}),60),n}return(0,t.default)(o,[{key:"componentDidMount",value:function(){this.initViewer()}},{key:"componentDidUpdate",value:function(n){n.urls===this.props.urls&&n.urls.length===this.props.urls.length||this.initViewer()}},{key:"componentWillUnmount",value:function(){this.viewer&&this.viewer.destroy()}},{key:"render",value:function(){var n=this,e=this.props.showThumbAlt;return l.default.createElement("ul",{ref:function(e){n.imgsEl=e},className:"z-viewer-ul ".concat(this.props.className)},l.default.createElement(m.TransitionGroup,{component:null,enter:!0,exit:!1,appear:!0},this.props.urls.map((function(o,a){var c="string"==typeof o?o:o.thumb?o.thumb:o.url,t="string"==typeof o?o:o.url,p="string"!=typeof o&&o.alt?o.alt:a+1;return l.default.createElement(m.CSSTransition,{key:a,timeout:f.animateTimout.flipInTime,classNames:"flipY",onEntered:n.initViewer,onExited:n.initViewer},l.default.createElement("li",{key:a},e?l.default.createElement("div",{className:"z-viewer-thumb"},l.default.createElement(g.default,{url:c,style:{height:"100%"}})):l.default.createElement(g.default,{url:c,style:{height:"100%"}}),e?l.default.createElement("div",{className:"z-viewer-alt"},p):null,l.default.createElement("img",{"data-url":t,alt:p})))}))))}}]),o}(s.default);e.Zviewer=b,b.propTypes={urls:i.default.oneOfType([i.default.arrayOf(i.default.string),i.default.arrayOf(i.default.object)]),className:i.default.string,showThumbAlt:i.default.bool},b.defaultProps={urls:[],className:"",showThumbAlt:!0};var y=b;e.default=y},"1Pc9":function(n,e,o){"use strict";var a=o("K6wJ");Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;a(o("v6s4"));var c=a(o("gm1+")),t=a(o("oHWW")),p=t.default.AmdDocHOC,r=(t.default.AshowDemoHOC,p(c.default,{}));e.default=r},duPH:function(n,e,o){"use strict";var a=o("K6wJ");Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.ZcodeHighlight=void 0;var c=a(o("q8s6")),t=a(o("MAG/")),p=a(o("6iOh")),r=a(o("1rR9")),d=a(o("IPZl")),l=a(o("v6s4")),s=a(o("kRUu")),i=a(o("XcRB")),u=a(o("XYcM"));function g(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var o,a=(0,d.default)(n);if(e){var c=(0,d.default)(this).constructor;o=Reflect.construct(a,arguments,c)}else o=a.apply(this,arguments);return(0,r.default)(this,o)}}o("lYVS"),o("dDAE"),o("roMe"),o("YO7D"),o("77Mx"),o("vV76"),o("QgYW"),o("X7dv"),o("d8H9"),o("Vqov");var f=function(n){(0,p.default)(o,n);var e=g(o);function o(){return(0,c.default)(this,o),e.apply(this,arguments)}return(0,t.default)(o,[{key:"componentDidMount",value:function(){var n=this.props,e=n.children,o=n.mode;if(e){if(e&&"html"===o){var a=e.replace(/\<pre/g,'<pre class="line-numbers"');this.boxEl.innerHTML=a}u.default.highlightAllUnder(this.boxEl)}}},{key:"render",value:function(){var n=this,e=this.props,o=e.children,a=e.mode,c=null;if(o&&"html"!==a){var t=l.default.createElement("code",{className:"language-".concat(this.props.lang)},this.props.children);c="block"===this.props.mode?l.default.createElement("pre",{className:"line-numbers"},t):t}return l.default.createElement("div",{ref:function(e){return n.boxEl=e}},c)}}]),o}(s.default);e.ZcodeHighlight=f,f.propTypes={mode:i.default.string,lang:i.default.string,children:i.default.string},f.defaultProps={lang:"html",mode:"block"};var m=f;e.default=m},"gm1+":function(n,e){n.exports='\x3c!-- @routePath: /eslint-doc --\x3e\n\n<h1 id="javascript-编码规范eslint-强制">JavaScript 编码规范(ESlint 强制))</h1>\n<p>本文档的目标是使<code>JavaScript</code>代码风格保持一致，容易被团队其他成员理解和后期的维护。</p>\n<h2 id="21-结构">2.1 结构</h2>\n<p>==[强制]== 使用<code>1</code>个<code>tab</code>做为一个缩进层级，<code>1</code>个<code>tab</code>等于<code>4</code>个空格，不允许使用 <code>2</code> 个空格。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nfunction foo() {\n    const obj = {};\n}\n\n// bad\nfunction foo() {\n    const obj = {};\n}</code></pre>\n<h2 id="212-空格">2.1.2 空格</h2>\n<p>==[强制]== 二元运算符两侧必须有一个空格，一元运算符与操作对象之间不允许有空格。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">let num = 0;\nnum = num1 + num2;\nnum--;</code></pre>\n<p>==[强制]== 用作代码块起始的左花括号 <code>{</code> 前必须有一个空格。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nif (condition) {\n}\n\nwhile (condition) {}\n\nfunction funcName() {}\n\n// bad\nif (condition) {\n}\n\nwhile (condition) {}\n\nfunction funcName() {}</code></pre>\n<p>==[强制]== <code>if / else / for / while / function / switch / do / try / catch / finally</code> 关键字后，必须有一个空格。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nif (condition) {\n}\n\nfor (let i = 0; i &lt; len; i++) {}\n\n(function() {})();\n\n// bad\nif (condition) {\n}\n\nfor (let i = 0; i &lt; len; i++) {}\n\n(function() {})();</code></pre>\n<p>==[强制]== 在对象创建时，属性中的 <code>:</code> 之后必须有空格，<code>:</code> 之前不允许有空格。<br>[建议] 在对象的每个属性最后都添加<code>,</code></p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nvar foo = {\n    name: &#39;Simon&#39;,\n    age: 29,\n};\n\n// bad\nvar foo = {\n    name: &#39;Simon&#39;,\n    age: 29,\n};</code></pre>\n<p>==[强制]== 函数声明、具名函数表达式、函数调用中，函数名和 <code>(</code> 之间不允许有空格。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nfunction foo() {}\n\nconst funcName = function foo() {};\n\nfoo();\n\n// bad\nfunction foo() {}\n\nconst funcName = function foo() {};\n\nfoo();</code></pre>\n<p>==[强制]== <code>,</code> 和 <code>;</code> 前不允许有空格。如果不位于行尾，<code>,</code> 和 <code>;</code> 后必须跟一个空格。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nfoo(param1, param2);\n\n// bad\nfoo(param1, param2);\nfoo(param1, param2);</code></pre>\n<p>==[强制]== 在函数调用、函数声明、括号表达式、属性访问、<code>if / for / while / switch / catch</code> 等语句中，<code>()</code> 和 <code>[]</code> 内紧贴括号部分不允许有空格。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\n\nfoo(param1, param2, param3);\n\nfoo(arr[index]);\n\nbool &amp;&amp; (variable += increament);\n\nif (num &gt; len) {\n}\n\nwhile (len--) {}\n\n// bad\n\nfoo(param1, param2, param3);\n\nfoo(arr[index]);\n\nbool &amp;&amp; (variable += increament);\n\nif (num &gt; len) {\n}\n\nwhile (len--) {}</code></pre>\n<p>==[强制]== 单行声明的数组与对象，如果包含元素，<code>{}</code> 和 <code>[]</code> 内紧贴括号部分不允许包含空格。</p>\n<p>解释：</p>\n<p>声明包含元素的数组与对象，内部元素的形式较为简单时，写在一行。元素复杂的情况，需要换行。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nvar arr1 = [];\nvar arr2 = [1, 2, 3];\nvar foo1 = {};\nvar foo2 = { name: &#39;Simon&#39; };\nvar foo3 = {\n    name: &#39;Simon&#39;,\n    age: 20,\n};\n\n// bad\nvar arr1 = [];\nvar arr2 = [1, 2, 3];\nvar foo1 = {};\nvar foo2 = { name: &#39;obj&#39; };\nvar foo3 = { name: &#39;obj&#39;, age: 20, sex: 1 };</code></pre>\n<p>==[强制]== 行尾不得有多余的空格。</p>\n<h2 id="213-换行">2.1.3 换行</h2>\n<p>==[强制]== 每个独立语句结束后必须换行。</p>\n<p>==[强制]== 每行不得超过 <code>120</code> 个字符。</p>\n<p>解释：</p>\n<p>超长的不可分割的代码允许例外，比如复杂的正则表达式。长字符串不在例外之列。</p>\n<p>==[强制]== 运算符处换行时，运算符必须在新行的行首。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nif ((obj &amp;&amp; obj.a &amp;&amp; obj.b) || obj.c) {\n    // Code\n}\n\nvar result = number1 + number2 + number3 + number4 + number5;\n\n// bad\nif ((obj &amp;&amp; obj.a &amp;&amp; obj.b) || obj.c) {\n    // Code\n}\n\nvar result = number1 + number2 + number3 + number4 + number5;</code></pre>\n<p>==[强制]== 在函数声明、函数表达式、函数调用、对象创建、数组创建、<code>for</code> 语句等场景中，禁止在 <code>,</code> 或 <code>;</code> 前换行。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nvar foo = {\n    a: 1,\n    b: 2,\n    c: 3,\n};\n\nbar(param1, param2, param3);\n\n// bad\nvar foo = {\n    a: 1,\n    b: 2,\n    c: 3,\n};\n\nbar(param1, param2, param3);</code></pre>\n<p>[建议] 不同行为或逻辑的语句集，使用空行隔开，更易阅读。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">function foo(param1, param2, param3) {\n    if (param2 === null) {\n        return;\n    }\n\n    param1.name = param3;\n}</code></pre>\n<p>[建议] 在语句的行长度超过 <code>120</code> 时，根据逻辑条件合理缩进。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// 较复杂的逻辑条件组合，将每个条件独立一行，逻辑运算符放置在行首进行分隔，或将部分逻辑按逻辑组合进行分隔。\n// 建议最终将右括号 ) 与左大括号 { 放在独立一行，保证与 `if` 内语句块能容易视觉辨识。\nif (element &amp;&amp; element.businessObject &amp;&amp; element.businessObject.get(&#39;custom:backTaskCode&#39;)) {\n    // Code\n}\n\n// 当参数过多时，将每个参数独立写在一行上，并将结束的右括号 ) 独立一行。\n// 所有参数必须增加一个缩进。\nfoo(param1, param2, param3);\n\n// 当函数调用时，如果有一个或以上参数跨越多行，应当每一个参数独立一行。\n// 这通常出现在匿名函数或者对象初始化等作为参数时，如 `setTimeout` 函数等。\nsetTimeout(function() {\n    alert(&#39;hello&#39;);\n}, 200);\n\nfoo(\n    &#39;id=&#39; + id,\n    function(data) {\n        callback(data);\n    },\n    300,\n);\n\n// 链式调用较长时采用缩进进行调整。\nfoo.then()\n    .catch()\n    .finally();\n\n// 三元运算符由3部分组成，因此其换行应当根据每个部分的长度不同，形成不同的情况。\nvar result = thisIsAVeryVeryLongCondition ? resultA : resultB;\n\nvar result = condition ? thisIsAVeryVeryLongResult : resultB;\n\n// 数组和对象初始化的混用，严格按照每个对象的 `{` 和结束 `}` 在独立一行的风格书写。\nvar array = [\n    {\n        // ...\n    },\n    {\n        // ...\n    },\n];</code></pre>\n<p>[建议] 对于 <code>if...else...</code>、<code>try...catch...finally</code> 等语句，推荐使用在 <code>}</code> 号后添加一个换行的风格，使代码层次结构更清晰，阅读性更好。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">if (condition) {\n    // some statements;\n} else {\n    // some statements;\n}\n\ntry {\n    // some statements;\n} catch (ex) {\n    // some statements;\n}</code></pre>\n<h2 id="214-语句">2.1.4 语句</h2>\n<p>==[强制]== 不得省略语句结束的分号。</p>\n<p>==[强制]== 在 <code>if / else / for / do / while</code> 语句中，即使只有一行，也不得省略块 <code>{...}</code>。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nif (condition) {\n    callFunc();\n}\n\n// bad\nif (condition) callFunc();\nif (condition) callFunc();</code></pre>\n<p>[强制] 函数定义结束不允许添加分号。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nfunction funcName() {}\n\n// bad\nfunction funcName() {}\n\n// 如果是函数表达式，分号是不允许省略的。\nvar funcName = function() {};\n// class钟箭头函数\nclass Foo {\n    bar = () =&gt; {\n        // code\n    };\n}</code></pre>\n<p>==[强制]== <code>IIFE</code> 必须在函数表达式外添加 <code>(</code>，非 <code>IIFE</code> 不得在函数表达式外添加 <code>(</code>。</p>\n<p>解释：</p>\n<p>IIFE = Immediately-Invoked Function Expression.</p>\n<p>额外的 ( 能够让代码在阅读的一开始就能判断函数是否立即被调用，进而明白接下来代码的用途。而不是一直拖到底部才恍然大悟。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nvar task = (function() {\n    // Code\n    return result;\n})();\n\nvar func = function() {};\n\n// bad\nvar task = (function() {\n    // Code\n    return result;\n})();\n\nvar func = function() {};</code></pre>\n<h2 id="22-命名">2.2 命名</h2>\n<p>==[强制]== <code>变量</code> 使用 <code>驼峰(Camel)命名法</code>。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">var formName = &#39;FORM&#39;;</code></pre>\n<p>==[强制]== <code>常量</code> 使用 <code>全部字母大写，单词间下划线分隔</code> 的命名方式。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">var FORM_NAME = &#39;FORM&#39;;</code></pre>\n<p>==[强制]== <code>函数</code> 使用 <code>驼峰(Camel)命名法</code>。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">function handleChange(e) {}</code></pre>\n<p>==[强制]== 函数的 <code>参数</code> 使用 <code>驼峰(Camel)命名法</code>。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">function getFormInstance(formName) {}</code></pre>\n<p>==[强制]== <code>类class</code> 使用 <code>Pascal命名法</code>。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">class ElementProperties {}</code></pre>\n<p>==[强制]== 类的 <code>方法</code> / <code>属性</code>，构造函数，原型 使用 <code>Camel命名法</code>。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">class ElementProperties {\n    formName = &#39;Simon&#39;;\n}\n\nfunction ElementProperties() {}\n\nTextNode.prototype.deepClone = function() {\n    // code\n};</code></pre>\n<p>==[强制]== <code>枚举变量</code> 使用 <code>Pascal命名法</code>，<code>枚举的属性</code> 使用 <code>全部字母大写，单词间下划线分隔</code> 的命名方式。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">var TypeCode = {\n    DOG_APPLY: 1,\n    DOG_DESTROY: 2,\n    DOG_MODIFY: 3,\n};</code></pre>\n<p>==[强制]== 由多个单词组成的缩写词，在命名中，根据当前命名法和出现的位置，所有字母的大小写与首字母的大小写保持一致。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">function XMLParser() {}\n\nfunction insertHTML(element, html) {}\n\nvar httpRequest = new HTTPRequest();</code></pre>\n<p>[建议] <code>类名</code> 使用 <code>名词</code>。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">function ElementProperties() {}</code></pre>\n<p>[建议] <code>函数名</code> 使用 <code>动宾短语</code>。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">function getStyle(element) {}</code></pre>\n<p>[建议] <code>boolean</code> 类型的变量使用 <code>is</code> 或 <code>has</code> 开头。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">const isReady = false;\nconst hasMoreCommands = false;</code></pre>\n<p>[建议] <code>Promise对象</code> 用 <code>动宾短语</code> 表达。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">const fetchData = axios.get(&#39;url&#39;);\nfetchData.then(callback);</code></pre>\n<h2 id="23-注释">2.3 注释</h2>\n<p>注释中参数的类型按以下类型进行标注：</p>\n<ul>\n<li>&lt;String&gt; &lt;Number&gt;</li>\n<li>&lt;Object&gt; &lt;Element&gt; &lt;Event&gt;</li>\n<li>&lt;Function&gt; &lt;Promise&gt;</li>\n<li>[&lt;String&gt;][&lt;number&gt;] [&lt;Object&gt;]</li>\n</ul>\n<p>函数注释</p>\n<ul>\n<li>约定规则：</li>\n<li>函数作用的简短描述</li>\n<li>param 参数的名称 参数的类型</li>\n<li>返回值，返回值的类型，无返回值可不写</li>\n</ul>\n<pre><code class="language-javascript">/**\n * 获取目标数据的对象集合\n * @param targetKeys [&lt;String&gt;]   目标数据的key的集合\n * @param listItems [&lt;Object&gt;]  全部数据集\n * @return result [&lt;Object&gt;]    已匹配的数据集\n * */\nfunction getTargetItems(targetKeys, listItems) {\n    return listItems.filter((item) =&gt; targetKeys.includes(item.key));\n}</code></pre>\n<p>对象的注释</p>\n<ul>\n<li>约定规则：</li>\n<li>注释内容尽量意简言赅</li>\n<li>每个属性之后写注释</li>\n<li>注释格式“<code>// 注释内容</code>”注意斜杠之间的空格</li>\n</ul>\n<pre><code class="language-javascript">const pageConfig = {\n    rightModalType: &#39;appModal&#39;, // 右边窗口的类型 appModal | mainModal\n    noticeType: &#39;notification&#39;, // 用于配置操作提示通告的方式\n    leftExpandWidth: 240, // 左侧边展开时的宽度\n    theme: &#39;mazarine&#39;, // 主页的主题 light | dark | mazarine\n};</code></pre>\n<h2 id="241-单行注释">2.4.1 单行注释</h2>\n<p>[强制] 必须独占一行。<code>//</code> 后跟一个空格，缩进与下一行被注释说明的代码一致。</p>\n<pre><code class="language-javascript">function foo() {\n    // 打印Hello\n    console.log(&#39;Hello&#39;);\n}</code></pre>\n<h2 id="242-多行注释">2.4.2 多行注释</h2>\n<p>[建议] 避免使用 <code>/*...*/</code> 这样的多行注释。有多行注释内容时，使用多个单行注释。</p>\n<h2 id="243-文档化注释">2.4.3 文档化注释</h2>\n<p>[强制] 为了便于代码阅读和自文档化，以下内容必须包含以 <code>/**...*/</code> 形式的块注释中。</p>\n<p>解释：</p>\n<ol>\n<li>文件</li>\n<li>namespace</li>\n<li>类</li>\n<li>函数或方法</li>\n<li>类属性</li>\n<li>事件</li>\n<li>全局变量</li>\n<li>常量</li>\n</ol>\n<p>[强制] 文档注释前必须空一行。</p>\n<h2 id="244-文件注释">2.4.4 文件注释</h2>\n<p>[强制] 文件顶部必须包含文件注释。</p>\n<h2 id="245-命名空间注释">2.4.5 命名空间注释</h2>\n<p>[建议] 命名空间使用 <code>@namespace</code> 标识。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">/**\n * @namespace\n */\nconst util = {};</code></pre>\n<h2 id="246-类的方法注释">2.4.6 类的方法注释</h2>\n<pre><code class="language-javascript">class Foo {\n    /**\n     * 发生变化\n     * @param &lt;event&gt; 事件对象\n     * */\n    handleChange(event) {\n        // code\n    }\n}</code></pre>\n<h2 id="247-细节注释">2.4.7 细节注释</h2>\n<p>对于内部实现、不容易理解的逻辑说明、摘要信息等，我们可能需要编写细节注释。</p>\n<p>[建议] 细节注释遵循单行注释的格式。说明必须换行时，每行是一个单行注释的起始。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">function foo(p1, p2) {\n    // 这里对具体内部逻辑进行说明\n    // 说明太长需要换行\n    console.log(&#39;Hello&#39;);\n}</code></pre>\n<p>[强制] 有时我们会使用一些特殊标记进行说明。特殊标记必须使用单行注释的形式。下面列举了一些常用标记：</p>\n<p>解释：</p>\n<ol>\n<li>TODO: 有功能待实现。此时需要对将要实现的功能进行简单说明。</li>\n<li>FIXME: 该处代码运行没问题，但可能由于时间赶或者其他原因，需要修正。此时需要对如何修正进行简单说明。</li>\n<li>HACK: 为修正某些问题而写的不太好或者使用了某些诡异手段的代码。此时需要对思路或诡异手段进行描述。</li>\n<li>XXX: 该处存在陷阱。此时需要对陷阱进行描述。</li>\n</ol>\n<pre><code>/**\n* TODO 过滤\n*/\nfunction foo() {\n    // code\n}</code></pre><h2 id="31-变量">3.1 变量</h2>\n<p>==[强制]== 变量，指未来值可能会发生变化的对象，未来不会发生变化的，需要定义为常量。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nlet name = &#39;Simon&#39;;\n// ... somecode\nname = &#39;Hello&#39;;\n\n// bad\nlet name = &#39;Simon&#39;;</code></pre>\n<h2 id="31-常量">3.1 常量</h2>\n<p>==[强制]== 常量，指未来不会发生变化的基本数据类型和内部发生变化的引用类型。</p>\n<pre><code class="language-javascript">// 基本类型\nconst name = &#39;Simon&#39;;\n\n// 引用类型\nconst arr = [];\n\narr.push(1); // [1]</code></pre>\n<h2 id="32-条件">3.2 条件</h2>\n<p>[强制] 在 Equality Expression 中使用类型严格的 <code>===</code>。仅当判断 <code>null</code> 或 <code>undefined</code> 时，允许使用 <code>== null</code>。</p>\n<p>解释：</p>\n<p>使用 <code>===</code> 可以避免等于判断中隐式的类型转换。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nif (age === 30) {\n    // ......\n}\n\n// bad\nif (age == 30) {\n    // ......\n}</code></pre>\n<p>==[强制]== 条件判断不超过 10 个</p>\n<p>解释：</p>\n<p>过多的使用 if 判断，会使业务逻辑过于复杂</p>\n<pre><code class="language-javascript">if (condition) {\n    // ......\n} else if (condition) {\n    // ......\n}\n......\nelse {\n    // ......\n}</code></pre>\n<p>[建议] 尽可能使用简洁的表达式。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// 字符串为空\n\n// good\nif (!name) {\n    // ......\n}\n\n// bad\nif (name === &#39;&#39;) {\n    // ......\n}</code></pre>\n<pre><code class="language-javascript">// 字符串非空\n\n// good\nif (name) {\n    // ......\n}\n\n// bad\nif (name !== &#39;&#39;) {\n    // ......\n}</code></pre>\n<pre><code class="language-javascript">// 数组非空\n\n// good\nif (collection.length) {\n    // ......\n}\n\n// bad\nif (collection.length &gt; 0) {\n    // ......\n}</code></pre>\n<pre><code class="language-javascript">// 布尔不成立\n\n// good\nif (!notTrue) {\n    // ......\n}\n\n// bad\nif (notTrue === false) {\n    // ......\n}</code></pre>\n<pre><code class="language-javascript">// null 或 undefined\n\n// good\nif (noValue == null) {\n    // ......\n}\n\n// bad\nif (noValue === null || typeof noValue === &#39;undefined&#39;) {\n    // ......\n}</code></pre>\n<p>[建议] 按执行频率排列分支的顺序。</p>\n<p>解释：</p>\n<p>按执行频率排列分支的顺序好处是：</p>\n<ol>\n<li>阅读的人容易找到最常见的情况，增加可读性。</li>\n<li>提高执行效率。</li>\n</ol>\n<p>[建议] 对于相同变量或表达式的多值条件，用 <code>switch</code> 代替 <code>if</code>，可行时可以使用设计模式来简化逻辑。</p>\n<p>[建议] 对于复杂一些的逻辑可以考虑用状态模式来实现</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nswitch (typeof variable) {\n    case &#39;object&#39;:\n        // ......\n        break;\n    case &#39;number&#39;:\n    case &#39;boolean&#39;:\n    case &#39;string&#39;:\n        // ......\n        break;\n}\n\n// bad\nvar type = typeof variable;\nif (type === &#39;object&#39;) {\n    // ......\n} else if (type === &#39;number&#39; || type === &#39;boolean&#39; || type === &#39;string&#39;) {\n    // ......\n}\n\n// god\nconst obj = {\n    object: {},\n    number: 12,\n    boolean: true,\n    string: &#39;hello&#39;,\n};\nconst result = obj[variable];</code></pre>\n<p>[建议] 如果函数或全局中的 <code>else</code> 块后没有任何语句，可以删除 <code>else</code>。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nfunction getName() {\n    if (name) {\n        return name;\n    }\n\n    return &#39;unnamed&#39;;\n}\n\n// bad\nfunction getName() {\n    if (name) {\n        return name;\n    } else {\n        return &#39;unnamed&#39;;\n    }\n}</code></pre>\n<h2 id="33-循环">3.3 循环</h2>\n<p>[建议] 不要在循环体中包含函数表达式，事先将函数提取到循环体外。</p>\n<p>解释：</p>\n<p>循环体中的函数表达式，运行过程中会生成循环次数个函数对象。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nfunction handler() {\n    // ......\n}\n\nfor (var i = 0, len = elements.length; i &lt; len; i++) {\n    var element = elements[i];\n    addListener(element, &#39;click&#39;, handler);\n}\n\n// bad\nfor (var i = 0, len = elements.length; i &lt; len; i++) {\n    var element = elements[i];\n    addListener(element, &#39;click&#39;, function() {});\n}</code></pre>\n<p>[建议] 对循环内多次使用的不变值，在循环外用变量缓存。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nvar width = wrap.offsetWidth + &#39;px&#39;;\nfor (var i = 0, len = elements.length; i &lt; len; i++) {\n    var element = elements[i];\n    element.style.width = width;\n    // ......\n}\n\n// bad\nfor (var i = 0, len = elements.length; i &lt; len; i++) {\n    var element = elements[i];\n    element.style.width = wrap.offsetWidth + &#39;px&#39;;\n    // ......\n}</code></pre>\n<p>[建议] 对有序集合进行遍历时，缓存 <code>length</code>。</p>\n<p>解释：</p>\n<p>虽然现代浏览器都对数组长度进行了缓存，但对于一些宿主对象和老旧浏览器的数组对象，在每次 <code>length</code> 访问时会动态计算元素个数，此时缓存 <code>length</code> 能有效提高程序性能。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">for (var i = 0, len = elements.length; i &lt; len; i++) {\n    var element = elements[i];\n    // ......\n}</code></pre>\n<p>[建议] 对有序集合进行顺序无关的遍历时，使用逆序遍历。</p>\n<p>解释：</p>\n<p>逆序遍历可以节省变量，代码比较优化。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">var len = elements.length;\nwhile (len--) {\n    var element = elements[len];\n    // ......\n}</code></pre>\n<h2 id="34-类型">3.4 类型</h2>\n<p>[建议] 基础类型检测优先使用 <code>typeof</code>。引用类型用 toString。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// string\ntypeof variable === &#39;string&#39;;\n\n// number\ntypeof variable === &#39;number&#39;;\n\n// boolean\ntypeof variable === &#39;boolean&#39;;\n\n// Function\ntypeof variable === &#39;function&#39;;\n\n// Object\nObject.prototype.toString.call(variable) === &#39;[object Object]&#39;;\n\n// RegExp\nvariable instanceof RegExp;\n\n// Array\nObject.prototype.toString.call(variable) === &#39;[object Array]&#39;;\n\n// null\nvariable === null;\n\n// null or undefined\nvariable == null;\n\n// undefined\ntypeof variable === &#39;undefined&#39;;</code></pre>\n<h2 id="342-类型转换">3.4.2 类型转换</h2>\n<p>[建议] 转换成 <code>string</code> 时，使用模板字符串。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nconst str = `${num}`;\n\n// bad\nnew String(num);\nnum.toString();\nString(num);</code></pre>\n<p>[建议] 转换成 <code>number</code> 时，通常使用 <code>+</code>。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nconst str = &#39;1&#39;;\n+str;\n\n// bad\nNumber(str);</code></pre>\n<p>[建议] <code>string</code> 转换成 <code>number</code>，要转换的字符串结尾包含非数字并期望忽略时，使用 <code>parseInt</code>。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">const width = &#39;200px&#39;;\nparseInt(width, 10);</code></pre>\n<p>==[强制]== 使用 <code>parseInt</code> 时，必须指定进制。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nparseInt(str, 10);\n\n// bad\nparseInt(str);</code></pre>\n<p>[建议] 转换成 <code>boolean</code> 时，使用 <code>!!</code>。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">const num = 3.14;\n!!num;</code></pre>\n<p>[建议] <code>number</code> 去除小数点，使用 <code>Math.floor</code> / <code>Math.round</code> / <code>Math.ceil</code>，不使用 <code>parseInt</code>。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nconst num = 3.14;\nMath.ceil(num);\n\n// bad\nconst num = 3.14;\nparseInt(num, 10);</code></pre>\n<h2 id="35-字符串">3.5 字符串</h2>\n<p>==[强制]== 字符串开头和结束使用单引号 <code>&#39;</code>。</p>\n<p>解释：</p>\n<ol>\n<li>输入单引号不需要按住 <code>shift</code>，方便输入。</li>\n</ol>\n<p>示例：</p>\n<pre><code class="language-javascript">var str = &#39;我是一个字符串&#39;;</code></pre>\n<p>==[强制]== 使用模板字符串。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nvar str = `&lt;ul&gt;\n        &lt;li&gt;第一项&lt;/li&gt;\n        &lt;li&gt;第二项&lt;/li&gt;\n    &lt;/ul&gt;`;\n\n// bad\nvar str2 = &#39;&#39;\n    + &#39;&lt;ul&gt;&#39;,\n    +    &#39;&lt;li&gt;第一项&lt;/li&gt;&#39;,\n    +    &#39;&lt;li&gt;第二项&lt;/li&gt;&#39;,\n    + &#39;&lt;/ul&gt;&#39;;</code></pre>\n<h2 id="36-对象">3.6 对象</h2>\n<p>==[强制]== 使用对象字面量 <code>{}</code> 创建新 <code>Object</code>。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nvar obj = {};\n\n// bad\nvar obj = new Object();</code></pre>\n<p>[建议] 对象创建时，如果一个对象的所有 <code>属性</code> 均可以不添加引号，建议所有 <code>属性</code> 不添加引号。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">var info = {\n    name: &#39;someone&#39;,\n    age: 28,\n};</code></pre>\n<p>[建议] 对象创建时，如果任何一个 <code>属性</code> 需要添加引号，则所有 <code>属性</code> 建议添加 <code>&#39;</code>。</p>\n<p>解释：</p>\n<p>如果属性不符合 Identifier 和 NumberLiteral 的形式，就需要以 StringLiteral 的形式提供。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nvar info = {\n    name: &#39;someone&#39;,\n    age: 28,\n    &#39;more-info&#39;: &#39;...&#39;,\n};\n\n// bad\nvar info = {\n    name: &#39;someone&#39;,\n    age: 28,\n    &#39;more-info&#39;: &#39;...&#39;,\n};</code></pre>\n<h2 id="37-数组">3.7 数组</h2>\n<p>==[强制]== 使用数组字面量 <code>[]</code> 创建新数组，除非想要创建的是指定长度的数组。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">// good\nvar arr = [];\n\n// bad\nvar arr = new Array();</code></pre>\n<p>==[强制]== 遍历对象不使用<code>for in</code>，使用 es6 的 Object.keys 来获取可枚举属性。</p>\n<pre><code class="language-javascript">// good\nconst obj = {\n    a: 1,\n    b: 2,\n    c: 3\n};\n\nObject.keys(obj).forEach(...)\n\n// bad\n\nfor (const prop in obj) {\n    ...\n}\n</code></pre>\n<p>==[强制]== 遍历数组不使用 <code>for in</code>。</p>\n<p>解释：</p>\n<p>数组对象可能存在数字以外的属性, 这种情况下 <code>for in</code> 不会得到正确结果。</p>\n<p>示例：</p>\n<pre><code class="language-javascript">var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];\n\n// 这里仅作演示, 实际中应使用 Object 类型\narr.other = &#39;other things&#39;;\n\n// 正确的遍历方式\nfor (let i = 0, len = arr.length; i &lt; len; i++) {\n    console.log(i);\n}\n\n// 错误的遍历方式\nfor (const i in arr) {\n    console.log(i);\n}</code></pre>\n<p>[建议] 不因为性能的原因自己实现数组排序功能，尽量使用数组的 <code>sort</code> 方法。</p>\n<p>解释：</p>\n<p>自己实现的常规排序算法，在性能上并不优于数组默认的 <code>sort</code> 方法。以下两种场景可以自己实现排序：</p>\n<ol>\n<li>需要稳定的排序算法，达到严格一致的排序结果。</li>\n<li>数据特点鲜明，适合使用桶排。</li>\n</ol>\n<p>[建议] 清空数组使用 <code>.length = 0</code>。</p>\n<h2 id="38-参数设计">3.8 参数设计</h2>\n<p>==[强制]== 函数的参数控制在<code>3</code>个以内, 多于<code>3</code>个参数改为 options 方式传入。</p>\n<p>解释：</p>\n<p>除去不定长参数以外，函数具备不同逻辑意义的参数建议控制在 <code>3</code> 个以内，过多参数会导致维护难度增大。</p>\n<pre><code class="language-javascript">// good\nfunction foo(param1, param2, param3) {}\n\n/**\n * @param options &lt;Object&gt; {param1: 1, param2: 2, param3: 3}\n */\nfunction foo(options) {}</code></pre>\n<h1 id="react-代码规范">React 代码规范</h1>\n<h2 id="目录">目录</h2>\n<ul>\n<li>命名</li>\n<li>注释</li>\n<li>组件 props 类型</li>\n</ul>\n<h2 id="命名">命名</h2>\n<p>==[强制]== 文件以<code>.js</code>或<code>.jsx</code>为后缀，同一个目录中禁止同时出现两种后缀</p>\n<p>==[强制]== 组件名</p>\n<pre><code class="language-javascript">class MyComponent extends Component {}</code></pre>\n<p>==[强制]== 组件名与文件名</p>\n<pre><code class="language-javascript">class MyComponent extends Component {}\n\nimport MyComponent fom &#39;./components/MyComponent&#39;;</code></pre>\n<p>==[强制]== 高阶组件名</p>\n<pre><code class="language-javascript">import appHoc from &#39;./appHoc&#39;;\nimport MyComponent fom &#39;./components/MyComponent&#39;;\n\nexport default appHoc(MyComponent);</code></pre>\n<p>==[强制]== 回调名</p>\n<p>使用 onXxx 形式作为 props 中用于回调的属性名称</p>\n<pre><code class="language-javascript">&lt;MyComponent onChange={this.handleChange} /&gt;</code></pre>\n<p>==[强制]== 组件方法名</p>\n<p>使用 handleXxxChange 形式作为 props 中用于回调的方法名称</p>\n<pre><code class="language-javascript">&lt;MyComponent onChange={this.handleNameChange} /&gt;\n\nhandleNameChange() {\n    // code\n}</code></pre>\n<h2 id="注释">注释</h2>\n<p>==[强制]== 组件文件注释</p>\n<p>约定规则：</p>\n<ul>\n<li>组件的创建人/创建时间</li>\n<li>组件描述</li>\n<li>调用时需要传入的 props</li>\n<li>props 的格式：名称-类型-是否必须-描述，格式尽量整洁对齐</li>\n</ul>\n<pre><code class="language-jsx">/**\n * created by simon on 2019/05/22\n * 评论模块组件\n * @props\n * activeRecordId:      &lt;Number|String&gt;   required      活动id\n * userId:              &lt;Number|String&gt;   required      用户id\n * moduleTitle:         &lt;String&gt;                        模块的标题\n * showTitle:           &lt;Boolean&gt;                       是否显示标题\n * showAvatar:          &lt;Boolean&gt;                       是否显示头像\n * showGiveLike:        &lt;Boolean&gt;                       显示点赞功能\n * onChange:            &lt;Function&gt;                      变化的时候回调\n * onDelete:            &lt;Function&gt;                      删除评论的时候回调\n * queryParams:         &lt;Object&gt;                        查询参数\n * showCommentButton:   &lt;Boolean&gt;                       显示评论按钮\n * commentButtonName:   &lt;String&gt;                        评论按钮名称\n * inputPlaceholder:    &lt;String&gt;                        inputPlaceholder\n * */\n\nimport React, { PureComponent, Fragment } from &#39;react&#39;;\nimport PropTypes from &#39;prop-types&#39;;\n\nexport default class CommentModule extends PureComponent {\n    // code\n}</code></pre>\n<h2 id="组件-props-类型">组件 props 类型</h2>\n<p>==[强制]== class 组件，props 要定义类型，非必传需默认值</p>\n<pre><code class="language-javascript">class MyComponent extends PureComponent {\n    static propTypes = {\n        handleValidate: PropTypes.func,\n        modeler: PropTypes.object.isRequired,\n        onChange: PropTypes.func,\n    };\n    static defaultProps = {\n        handleValidate: () =&gt; {\n            // do nothing\n        },\n        onChange: () =&gt; {\n            // do nothing\n        },\n    };\n}</code></pre>\n<h2 id="jsx-代码风格">jsx 代码风格</h2>\n<p>==[强制]== 组件中对象必须左右带空格，属性名之后带空格</p>\n<pre><code class="language-javascript">&lt;MyComponent data={{ name: &#39;Simon&#39;, age: 29 }} /&gt;</code></pre>\n<p>==[强制]== 解构赋值，左右空格，每个属性之间带空格</p>\n<pre><code class="language-javascript">function handleChange(record) {\n    const { name, title } = record;\n    // code\n}</code></pre>\n<p>==[强制]== 组件代码顺序，props,state 生命周期钩子等在 render 之前，方法在 render 之后定义</p>\n<pre><code class="language-jsx">class MyComponent extends Component {\n    state = {};\n\n    componentDidMount() {}\n\n    componentDidUpdate() {}\n\n    render() {}\n\n    handleChange() {}\n}</code></pre>\n<p>==[强制]== 无内容标签自闭合，并且闭合之前添加空格</p>\n<pre><code class="language-jsx">    // good\n    &lt;MyComponent /&gt;\n    &lt;div /&gt;\n\n    // bad\n    &lt;MyComponent&gt;&lt;/MyComponent&gt;\n    &lt;div/&gt;\n    &lt;div&gt;&lt;/div&gt;</code></pre>\n<p>==[强制]== 代码缩进</p>\n<pre><code class="language-jsx">// Good\nclass Message {\n    render() {\n        return (\n            &lt;div&gt;\n                &lt;span&gt;Hello World&lt;/span&gt;\n            &lt;/div&gt;;\n        );\n    }\n}\n\n// Bad\nclass Message {\n    render() {\n        return &lt;div&gt;\n            &lt;span&gt;Hello World&lt;/span&gt;\n        &lt;/div&gt;;\n    }\n}</code></pre>\n<p>==[强制]== 多个属性必须换行</p>\n<pre><code class="language-jsx">// good\n&lt;MyComponent\n    data={data}\n    name={&#39;Si&#39;}\n    onChange={this.handleChange}\n/&gt;\n\n// bad\n&lt;MyComponent data={data} name={&#39;Si&#39;} onChange={this.handleChange} /&gt;</code></pre>\n<p>==[强制]== 以字符串字面量作为值的属性使用双引号（&quot;），在其它类型表达式中的字符串使用单引号（&#39;）。</p>\n<pre><code class="language-jsx">// Good\n&lt;Foo bar=&quot;bar&quot; /&gt;\n&lt;Foo style={{width: &#39;20px&#39;}} /&gt;\n\n// Bad\n&lt;Foo bar=&#39;bar&#39; /&gt;\n&lt;Foo style={{ width: &quot;20px&quot; }} /&gt;</code></pre>\n<p>==[强制]== 对于值为 true 的属性，省去值部分</p>\n<pre><code class="language-jsx">// Good\n&lt;Foo visible /&gt;\n\n// Bad\n&lt;Foo visible={true} /&gt;</code></pre>\n<p>==[强制]== 在需要使用<code>key</code>的循环列表，禁止使用<code>index</code>作为<code>key</code></p>\n<pre><code class="language-jsx">// Bad\n{\n    list.map((item, index) =&gt; &lt;Foo key={index} {...item} /&gt;);\n}\n\n// Good\n{\n    list.map((item) =&gt; &lt;Foo key={item.id} {...item} /&gt;);\n}</code></pre>\n<p>[建议] 避免在 JSX 的属性值中直接使用对象和函数表达式</p>\n<pre><code class="language-javascript">// Bad\n&lt;button\n    type=&quot;button&quot;\n    onClick={() =&gt; this.alertMessage(&#39;hello&#39;)}\n&gt;提示&lt;/button&gt;\n\n// Good\n&lt;button\n    type=&quot;button&quot;\n    onClick={this.handleClick}\n&gt;提示&lt;/button&gt;</code></pre>\n<h1 id="css-代码规范">CSS 代码规范</h1>\n<h2 id="1-前言">1 前言</h2>\n<p>CSS 作为网页样式的描述语言，一直有着广泛的应用。本文档的目标是使 CSS 代码风格保持一致，容易被理解和被维护。</p>\n<p>虽然本文档是针对 CSS 设计的，但是在使用各种 CSS 的预编译(如 less、sass 等)时，适用的部分也应尽量遵循本文档的约定。</p>\n<h2 id="2-代码风格">2 代码风格</h2>\n<p>==[强制]== 使用<code>1</code>个<code>tab</code>做为一个缩进层级，<code>1</code>个<code>tab</code>等于<code>4</code>个空格，不允许使用 <code>2</code> 个空格。</p>\n<p>示例：</p>\n<pre><code class="language-css">.selector {\n    margin: 0;\n    padding: 0;\n}</code></pre>\n<h2 id="23-空格">2.3 空格</h2>\n<p>==[强制]== <code>选择器</code> 与 <code>{</code> 之间必须包含空格。</p>\n<p>示例：</p>\n<pre><code class="language-css">.selector {\n}</code></pre>\n<p>==[强制]== <code>属性名</code> 与之后的 <code>:</code> 之间不允许包含空格， <code>:</code> 与 <code>属性值</code> 之间必须包含空格。</p>\n<p>示例：</p>\n<pre><code class="language-css">margin: 0;</code></pre>\n<p>==[强制]== <code>列表型属性值</code> 书写在单行时，<code>,</code> 后必须跟一个空格。</p>\n<p>示例：</p>\n<pre><code class="language-css">font-family: Arial, sans-serif;</code></pre>\n<h2 id="24-行长度">2.4 行长度</h2>\n<p>==[强制]== 每行不得超过 <code>120</code> 个字符，除非单行不可分割。</p>\n<p>解释：</p>\n<p>常见不可分割的场景为 URL 超长。</p>\n<p>[建议] 对于超长的样式，在样式值的 <code>空格</code> 处或 <code>,</code> 后换行，建议按逻辑分组。</p>\n<p>示例：</p>\n<pre><code class="language-css">/* 不同属性值按逻辑分组 */\nbackground: transparent url(aVeryVeryVeryLongUrlIsPlacedHere) no-repeat 0 0;\n\n/* 可重复多次的属性，每次重复一行 */\nbackground-image: url(aVeryVeryVeryLongUrlIsPlacedHere) url(anotherVeryVeryVeryLongUrlIsPlacedHere);\n\n/* 类似函数的属性值可以根据函数调用的缩进进行 */\nbackground-image: -webkit-gradient(\n    linear,\n    left bottom,\n    left top,\n    color-stop(0.04, rgb(88, 94, 124)),\n    color-stop(0.52, rgb(115, 123, 162))\n);</code></pre>\n<h2 id="25-选择器">2.5 选择器</h2>\n<p>==[强制]== 当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。</p>\n<p>示例：</p>\n<pre><code class="language-css">/* good */\n.post,\n.page,\n.comment {\n    line-height: 1.5;\n}\n\n/* bad */\n.post,\n.page,\n.comment {\n    line-height: 1.5;\n}</code></pre>\n<p>==[强制]== <code>&gt;</code>、<code>+</code>、<code>~</code> 选择器的两边各保留一个空格。</p>\n<p>示例：</p>\n<pre><code class="language-css">/* good */\nmain &gt; nav {\n    padding: 10px;\n}\n\nlabel + input {\n    margin-left: 5px;\n}\n\ninput:checked ~ button {\n    background-color: #69c;\n}\n\n/* bad */\nmain &gt; nav {\n    padding: 10px;\n}\n\nlabel + input {\n    margin-left: 5px;\n}\n\ninput:checked ~ button {\n    background-color: #69c;\n}</code></pre>\n<p>==[强制]== 属性选择器中的值必须用双引号包围。</p>\n<p>解释：</p>\n<p>不允许使用单引号，不允许不使用引号。</p>\n<p>示例：</p>\n<pre><code class="language-css">/* good */\narticle[character=&#39;juliet&#39;] {\n    voice-family: &#39;Vivien Leigh&#39;, victoria, female;\n}\n\n/* bad */\narticle[character=&#39;juliet&#39;] {\n    voice-family: &#39;Vivien Leigh&#39;, victoria, female;\n}</code></pre>\n<h2 id="26-属性">2.6 属性</h2>\n<p>==[强制]== 属性定义必须另起一行。</p>\n<p>示例：</p>\n<pre><code class="language-css">/* good */\n.selector {\n    margin: 0;\n    padding: 0;\n}\n\n/* bad */\n.selector {\n    margin: 0;\n    padding: 0;\n}</code></pre>\n<p>==[强制]== 属性定义后必须以分号结尾。</p>\n<p>示例：</p>\n<pre><code class="language-css">/* good */\n.selector {\n    margin: 0;\n}\n\n/* bad */\n.selector {\n    margin: 0;\n}</code></pre>\n<h2 id="31-选择器">3.1 选择器</h2>\n<p>==[强制]== 如无必要，不得为 <code>id</code>、<code>class</code> 选择器添加类型选择器进行限定。</p>\n<p>解释：</p>\n<p>在性能和维护性上，都有一定的影响。</p>\n<p>示例：</p>\n<pre><code class="language-css">/* good */\n#error,\n.danger-message {\n    font-color: #c00;\n}\n\n/* bad */\ndialog#error,\np.danger-message {\n    font-color: #c00;\n}</code></pre>\n<p>[建议] 选择器的嵌套层级应不大于 <code>3</code> 级，位置靠后的限定条件应尽可能精确。</p>\n<p>示例：</p>\n<pre><code class="language-css">/* good */\n#username input {\n}\n.comment .avatar {\n}\n\n/* bad */\n.page .header .login #username input {\n}\n.comment div * {\n}\n\n// less\n.page {\n    .header {\n        .login {\n            #username {\n                input {\n                }\n            }\n        }\n    }\n}</code></pre>\n<h2 id="32-属性缩写">3.2 属性缩写</h2>\n<p>[建议] 在可以使用缩写的情况下，尽量使用属性缩写。</p>\n<p>示例：</p>\n<pre><code class="language-css">/* good */\n.post {\n    font: 12px/1.5 arial, sans-serif;\n}\n\n/* bad */\n.post {\n    font-family: arial, sans-serif;\n    font-size: 12px;\n    line-height: 1.5;\n}</code></pre>\n<p>[建议] 使用 <code>border</code> / <code>margin</code> / <code>padding</code> 等缩写时，应注意隐含值对实际数值的影响，确实需要设置多个方向的值时才使用缩写。</p>\n<p>解释：</p>\n<p><code>border</code> / <code>margin</code> / <code>padding</code> 等缩写会同时设置多个属性的值，容易覆盖不需要覆盖的设定。如某些方向需要继承其他声明的值，则应该分开设置。</p>\n<p>示例：</p>\n<pre><code class="language-css">/* good */\n.page {\n    margin-right: auto;\n    margin-left: auto;\n}\n\n.featured {\n    border-width: 1px;\n    border-color: #69c;\n}\n\n/* bad */\n.page {\n    margin: 5px auto;\n}\n\n.featured {\n    border: 1px solid #69c;\n}</code></pre>\n<h2 id="33-important">3.3 !important</h2>\n<p>[建议] 尽量不使用 <code>!important</code> 声明。</p>\n<p>[建议] 当需要强制指定样式且不允许任何场景覆盖时，通过标签内联和 <code>!important</code> 定义样式。</p>\n<h2 id="41-文本">4.1 文本</h2>\n<p> ==[强制]== 文本内容必须用双引号包围。</p>\n<p>解释：</p>\n<p>文本类型的内容可能在选择器、属性值等内容中。</p>\n<p>示例：</p>\n<pre><code class="language-css">/* good */\nhtml[lang|=&#39;zh&#39;] q:before {\n    font-family: &#39;Microsoft YaHei&#39;, sans-serif;\n    content: &#39;“&#39;;\n}\n\nhtml[lang|=&#39;zh&#39;] q:after {\n    font-family: &#39;Microsoft YaHei&#39;, sans-serif;\n    content: &#39;”&#39;;\n}\n\n/* bad */\nhtml[lang|=&#39;zh&#39;] q:before {\n    font-family: &#39;Microsoft YaHei&#39;, sans-serif;\n    content: &#39;“&#39;;\n}\n\nhtml[lang|=&#39;zh&#39;] q:after {\n    font-family: &#39;Microsoft YaHei&#39;, sans-serif;\n    content: &#39;”&#39;;\n}</code></pre>\n<h2 id="42-数值">4.2 数值</h2>\n<p>==[强制]== 当数值为 0 - 1 之间的小数时，省略整数部分的 <code>0</code>。</p>\n<p>示例：</p>\n<pre><code class="language-css">/* good */\npanel {\n    opacity: 0.8;\n}\n\n/* bad */\npanel {\n    opacity: 0.8;\n}</code></pre>\n<h2 id="43-url">4.3 url()</h2>\n<p>==[强制]== <code>url()</code> 函数中的路径不加引号。</p>\n<p>示例：</p>\n<pre><code class="language-css">body {\n    background: url(bg.png);\n}</code></pre>\n<p>[建议] <code>url()</code> 函数中的绝对路径可省去协议名。</p>\n<p>示例：</p>\n<pre><code class="language-css">body {\n    background: url(//baidu.com/img/bg.png) no-repeat 0 0;\n}</code></pre>\n<h2 id="44-长度">4.4 长度</h2>\n<p>==[强制]== 长度为 <code>0</code> 时须省略单位。 (也只有长度单位可省)</p>\n<p>示例：</p>\n<pre><code class="language-css">/* good */\nbody {\n    padding: 0 5px;\n}\n\n/* bad */\nbody {\n    padding: 0px 5px;\n}</code></pre>\n<h2 id="45-颜色">4.5 颜色</h2>\n<p>==[强制]== RGB 颜色值必须使用十六进制记号形式 <code>#rrggbb</code>。不允许使用 <code>rgb()</code>。</p>\n<p>解释：</p>\n<p>带有 alpha 的颜色信息可以使用 <code>rgba()</code>。使用 <code>rgba()</code> 时每个逗号后必须保留一个空格。</p>\n<p>示例：</p>\n<pre><code class="language-css">/* good */\n.success {\n    box-shadow: 0 0 2px rgba(0, 128, 0, 0.3);\n    border-color: #008000;\n}\n\n/* bad */\n.success {\n    box-shadow: 0 0 2px rgba(0, 128, 0, 0.3);\n    border-color: rgb(0, 128, 0);\n}</code></pre>\n<p>==[强制]== 颜色值可以缩写时，必须使用缩写形式。</p>\n<p>示例：</p>\n<pre><code class="language-css">/* good */\n.success {\n    background-color: #aca;\n}\n\n/* bad */\n.success {\n    background-color: #aaccaa;\n}</code></pre>\n<p>==[强制]== 颜色值不允许使用命名色值。</p>\n<p>示例：</p>\n<pre><code class="language-css">/* good */\n.success {\n    color: #90ee90;\n}\n\n/* bad */\n.success {\n    color: lightgreen;\n}</code></pre>\n<p>[建议] 颜色值中的英文字符采用小写。如不用小写也需要保证同一项目内保持大小写一致。</p>\n<p>示例：</p>\n<pre><code class="language-css">/* good */\n.success {\n    background-color: #aca;\n    color: #90ee90;\n}\n\n/* good */\n.success {\n    background-color: #aca;\n    color: #90ee90;\n}\n\n/* bad */\n.success {\n    background-color: #aca;\n    color: #90ee90;\n}</code></pre>\n'},oZFy:function(n,e,o){var a={"./AmdDocHOC/index.jsx":"xRbD","./AshowDemoHOC/index.jsx":"+GLa"};function c(n){var e=t(n);return o(e)}function t(n){if(!o.o(a,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return a[n]}c.keys=function(){return Object.keys(a)},c.resolve=t,n.exports=c,c.id="oZFy"},v5v4:function(n,e,o){"use strict";var a=o("K6wJ");Object.defineProperty(e,"__esModule",{value:!0}),e.ZpageWraperHOC=t,e.default=void 0;var c=a(o("6sYb"));function t(){return c.default}var p=t;e.default=p},vApo:function(n,e,o){"use strict";var a=o("K6wJ");Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.ZbgImage=void 0;var c=a(o("q8s6")),t=a(o("MAG/")),p=a(o("6iOh")),r=a(o("1rR9")),d=a(o("IPZl")),l=a(o("v6s4")),s=a(o("kRUu")),i=a(o("XcRB"));function u(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var o,a=(0,d.default)(n);if(e){var c=(0,d.default)(this).constructor;o=Reflect.construct(a,arguments,c)}else o=a.apply(this,arguments);return(0,r.default)(this,o)}}o("dLwK");var g=function(n){(0,p.default)(o,n);var e=u(o);function o(){return(0,c.default)(this,o),e.apply(this,arguments)}return(0,t.default)(o,[{key:"render",value:function(){var n=this,e="z-bg-image-box z-flex-items-center ".concat(this.props.className?this.props.className:""," ").concat(this.props.url?"":"no-url");return l.default.createElement("div",{className:e,onClick:function(e){n.props.onClick&&n.props.onClick(e)},style:this.props.style},this.props.url?null:l.default.createElement("span",null,"无图片"),l.default.createElement("div",{className:"z-bg-image is-bg-".concat(this.props.position),style:{backgroundImage:"url(".concat(this.props.url,")")}}),this.props.children)}}]),o}(s.default);e.ZbgImage=g,g.propTypes={url:i.default.string,position:i.default.string,className:i.default.string,style:i.default.object,onClick:i.default.func},g.defaultProps={position:"center"};var f=g;e.default=f}}]);