<!-- @routePath:/HOC-doc/ZmainHOC-doc -->

# 主页布局：ZmainHOC

`ZmainHOC`是一个函数，传入`pageConfig`参数配置，返回一个主页布局结构(内置固定一种二级路由布局)的`组件`(我们这里称它为`main`组件)，凡是二级路由的子组件都可以使用<span class="z-history-href" data-path="/main/context-doc/ZerodMainContext-doc">上下文/ZerodMainContext</span>

<!-- @import: ./demos.md -->

## pageConfig

<!-- prettier-ignore-start -->
<!-- SOMETHING AUTO-GENERATED BY TOOLS - START -->

| 参数              | 说明                                                                 | 类型       | 默认值 |
| ----------------- | -------------------------------------------------------------------- | ---------- | ------ |
| componentDidMount | main 组件加载完的钩子,考虑到可能走异步,提供一个一定要调用的 callback <br/>callback(userInfo = {}, menuData = []),userInfo 是用户登录后要储存的一个对象；menuData 是侧边导航的数据(map 结构由 pageConfig.sideMenu.mapKeys 对应)，menuData 除了 pageConfig.sideMenu.mapKeys 对应的属性外，还可以选择添加 openMode : 可选 "newWindow"\|"iframe"\|"iframe-full"； $router:是一个对象，提供history和location属性| (callback,$router,tool)=>{} | -- |
| globalLoading | 在 callback 调用前显示的内容 | ReactNode \|<br/> ()=>(\<span\>加载中...<\/span>) | -- |
| noticeType | 用于配置操作提示通告的方式 | "notification" \| "message" | "message" |
| leftExpandWidth | 左侧栏展开时的宽度 | string \| number | 240 |
| theme | 主题 | "light" \| "dark" \| "mazarine" | "light" |
| logo | logo 区域配置 | object | -- |
| <i class="zero-icon zerod-shengchangzhouqi"></i>logo.render | logo 区域内容的渲染钩子 | function | -- |
| mainRoutes | 路由配置，更多属性请查看[react-reouter 的 Route](https://reacttraining.com/react-router/web/api/Route) | array[object] \| <br/> (menuData,tool)=>(array[object]) | [] |
| mainRoutes[].path      | 路由路径，会拼接当前父路由的路径 | string |--|
| mainRoutes[].component | 路由组件 | ReactComponent | -- |
| mainRoutes[].redirect | 是否重定路由 | boolean | -- |
| mainRoutes[].to | 将 path 重定向到的路由路径 | string | -- |
| mainRoutes[].keppAlive | 是否切换到其他路由前缓存当前路由组件，必需组件内有一个真实的 html 根节点，也可以 keepAlive:{domProperties:true} 自动添加一个 div 作为根节点，如果影响了组件内 html 布局，可以 keepAlive:{domProperties:{className:"z-wrapper-box"}} 给 div 根节点添加属性 | boolean \| object | false |
| sideMenu | 侧边导航配置 | object | -- |
| sideMenu.collapseBtnRender | 折叠按钮的渲染函数 | (collapsed)=>(<Icon\/>) | -- |
| sideMenu.onSelect | 点击选中菜单项触发的函数，return false 则不会跳转 menuData 中对应项的 path 路径 | ({item,key,selectedKeys})=>{} | -- |
| sideMenu.openAllSubmenu | 侧边导航存在二级导航时，是否默认所有的一级导航都是打开状态 | boolean | false |
| sideMenu.noParentPath | 如为true,则菜单导航的path不会与父节点的path拼接 | boolean | false |
| sideMenu.mapKeys | menuData 的 map 对象 key 的映射 | object | -- |
| sideMenu.mapKeys.path | 导航跳转的路径映射字段，当noParentPath=false时与每一级的父节点path拼接后与完整的路由路径对应，当noParentPath=true时就是与完整的路由路径对应 | string | -- |
| sideMenu.mapKeys.name | 导航名称的映射字段 | string | -- |
| sideMenu.mapKeys.children | 子导航的映射字段 | string | -- |
| headerLeftRender | 右侧顶部栏左边内容的渲染钩子 | (tool)=>{} | -- |
| headerRightRender | 右侧顶部栏右边内容的渲染钩子 | (tool)=>{} | -- |
| showCollapseBtn | 是否显示折叠按钮 | boolean \| (tool)=>{} | -- |
| beforeToggleCollapse | 侧边栏折叠按钮触发后，过渡动画之前回调,参数有折叠状态collapsed | (collapsed,tool)=>{} | -- |
| afterToggleCollapse | 侧边栏折叠按钮触发后，过渡动画之后回调,参数有折叠状态collapsed | (collapsed,tool)=>{} | -- |

<!-- SOMETHING AUTO-GENERATED BY TOOLS - END -->
<!-- prettier-ignore-end -->

## 自定义主页布局

如果想自定义布局结构，又想能使用<span class="z-history-href" data-path="/main/context-doc/ZerodMainContext-doc">上下文/ZerodMainContext</span>，ZmainHOC 需要的参数就不是 pageConfig 参数配置 ，而是自己写的 Main 组件：`ZmainHOC(MainComponent,componentDidMount)`,其中 componentDidMount 参数同 pageConfig 的 componentDidMount

```jsx
//componentDidMount的callback调用需多些参数
const NewMain = ZmainHOC(MainComponent, (callback) => {
    //callback必须调用，可在异步之后调用
    callback(
        //保存的用户信息
        {},
        //侧边导航数据
        [
            {
                permUrl: 'start-doc',
                permName: '开始',
            },
        ],
        //mapKeys  同 pageConfig.sideMenu 的mapKeys
        { iconClass: 'permIconUrl', path: 'permUrl', name: 'permName', children: 'children' },
        //路由配置数据,同pageConfig的mainRoutes
        mainRoutes,
    );
});
```

这时`MainComponent`组件的 props 会添加`getSideMenuTemplate`和`getMaimRouteTemplate`两个方法，可在`MainComponent`组件的 render 函数中使用

```jsx
//得到的sideMenuBody是侧边导航布局内容，必须放进Zlayout内
const sideMenuBody = this.props.getSideMenuTemplate({
    theme: 'mazarine', //同pageConfig的theme : light | dark | mazarine
    isCollapse: false, //是否折叠侧边导航
    openAllSubmenu: false, //是否默认打开所有的二级导航
    onSelect: function({ item, key, selectedKeys }) {}, //同pageCofig.sideMenu.onSelect
});
//得到的mainRouteBody是二级路由区域布局内容，必须放进Zlayout内
const mainRouteBody = this.props.getMaimRouteTemplate(id, { onCollapseClick }); //id可选，当一个应用中出现两次 ZmainHOC时，就要用id区分, onCollapseClick 折叠按钮的点击事件
```

必须使用 <span class="z-history-href" data-path="/main/component-doc/Zlayout-doc">组件/Zlayout</span> 来布局

```jsx
class MainComponent extends React.Component {
    componentDidMount() {}
    render() {
        //自定义主页布局，经过ZmainHOC包装的组件，会有this.props.getSideMenuTemplate和this.props.getMaimRouteTemplate两个方法
        return (
            <Zlayout>
                <Zlayout.Zheader style={{ backgroundColor: '#0A1131' }}>
                    <Logo />
                </Zlayout.Zheader>
                <Zlayout.Zbody scroll={false}>
                    <Zlayout flexRow>
                        <Zlayout width={'320px'}>
                            {this.props.getSideMenuTemplate({
                                theme: 'dark', //同pageCofig.theme
                                isCollapse: false, //侧栏折叠状态
                                openAllSubmenu: true, //同pageCofig.sideMenu.openAllSubmenu
                            })}
                        </Zlayout>
                        <Zlayout>{this.props.getMaimRouteTemplate('my_main_body')}</Zlayout>
                    </Zlayout>
                </Zlayout.Zbody>
            </Zlayout>
        );
    }
}
```

## tool 参数

`tool`是一个对象，里面的属性同 <span class="z-history-href" data-path="/main/context-doc/ZerodMainContext-doc">上下文/ZerodMainContext</span> 提供的内容
